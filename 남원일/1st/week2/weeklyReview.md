# 베스트앨범

## 💡 문제 풀이 방법

- 먼저 장르별 플레이 횟수를 카운팅한다.
- 장르별 플레이 횟수 순서대로 정렬한다.
- 플레이 횟수 순서대로 정렬된 목록을 바탕으로 해당 장르의 1위 2위 곡을 찾는다.
- 곡을 찾았으면 찾은 것을 기반으로 최종 결과로 반환할 배열에 추가한다.
- 최종 반환할 배열을 리턴한다.

## 🤔 고민한 부분

- 문제 풀이하면서 고민했던 부분들

  - 장르의 합을 구함과 동시에 1등과 2등을 기록하려고 시도했으나 생각처럼 잘 구현되지 못하였다.

- 풀지 못하였다면 생각이 막혔던 부분
  - 좋은 풀이를 시도하려다가 적용이 잘 안되었고 그로인해 풀이 방법을 변경하면서 시간을 많이 소요하였다.

## ⏰ 시간 복잡도

- 현재 시간복잡도 : O(n^2)으로 추정된다.
- 시간 복잡도를 줄일 수 있는 방법
  - 장르별 횟수 합산을 하는 동시에 해당 plays를 바탕으로 1등과 2등을 갱신할 수 있는 방법이 있을것 같다.
  - 이렇게 풀린다면 최종적으로 시간복잡도는 sort의 시간복잡도인 o(nlogn)이 될 것으로 보인다.

## ✍️ 배운점, 팁 공유

- 객체를 다루는데 아직 부족함을 많이 느낀다. 객체를 이용하는 코드를 쓰면서 에러를 많이 마주하는 것 같다. 잘못하는 패턴을 잘 정리해야 할것 같다.

# Container With Most Water

## 💡 문제 풀이 방법

- 테스트케이스 55번에서 막힘, 시간복잡도로 인해 풀이 성공을 하지 못하였다.
- 높이별 인덱스 배열을 만든다.
- 해당 배열의 맨앞이 최소값, 맨뒤가 최대값인 점을 활용헤 특정 높이 값에 도달한 경우 해당 높이 보다 높은 것들중에 인덱스의 최대 최소값만 활용하여 넓이를 계산한다. 그러면서 최대값을 계속 갱신해나간다.

## 🤔 고민한 부분

- 이중 for문이여서 for문 도는 와중에도 최대한 순회를 범위를 좁히려는 시도를 많이 했다.
- 허나 결국은 이중 for문이여서인지 시간제한을 통과하지 못했다.

## ⏰ 시간 복잡도

- 현재 시간복잡도 : O(n^2)이다. 그로 인해 테스트케이스 55번이후는 시간제한에 걸려버린다.
- 시간 복잡도를 줄일 수 있는 방법
  - 시간복잡도가 O(n)인 기법을 활용해야만한다. two pointer전략이 가장 적합한 것같다.
  - two Pointer전략이 대부분 좋은 풀이로 공유가 되는데 직관적으로 논리가 적용가능 이해가 안되고 있다. two Pointer를 쓰면 왠지 예외가 생길것다고 느낀다.

## ✍️ 배운점, 팁 공유

- frequency Counter 기법에 너무 매몰되었던 같다. 문제 상황에 맞는 풀이 기법을 잘 판단하는 능력을 길러야 할 필요성을 느낀다.
- two Pointer전략이 대부분 좋은 풀이로 공유가 되는데 직관적으로 논리를 이해 못하고 있다. two Pointer를 쓰면 왠지 예외가 생길것다고 느낀다.

- 좋은 풀이 코드 기록
- ```
  var maxArea = function (height) {
    let ans = 0;
    let i = 0;
    let j = height.length - 1;

    while (i < j) {
      ans = Math.max(ans, Math.min(height[i], height[j]) * (j - i));
      height[i] <= height[j] ? i++ : j--;
    }
    return ans;
  };
  ```
